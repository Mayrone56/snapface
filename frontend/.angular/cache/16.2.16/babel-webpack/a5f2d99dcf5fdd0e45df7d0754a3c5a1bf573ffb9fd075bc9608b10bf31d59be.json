{"ast":null,"code":"import { filter, interval, tap } from 'rxjs'; // Importation des fonctions et classes nécessaires depuis la bibliothèque RxJS.\nimport { map } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/router\";\nimport * as i2 from \"./header/header.component\";\n// La classe AppComponent est le composant principal de cette application. Elle implémente l'interface OnInit, ce qui signifie qu'une méthode ngOnInit sera appelée après l'initialisation du composant\nexport class AppComponent {\n  // Méthode ngOnInit, exécutée juste après la création du composant, idéale pour l'initialisation des variables ou l'appel des observables\n  ngOnInit() {\n    // Le $ est une convention qui permet de dire que c'est un Obervable\n    // Toutes les secondes, l'Observable émet un nombre\n    // const interval$ = interval(1000);\n    // // Ce nombre est ensuite capté et traité par la méthode passée à  subscribe()\n    // interval$.subscribe((value) => console.log('Observable', value));\n    // // Test qui prmet d'identifier plusieurs d'instances d'Obervables\n    // setTimeout(() => {\n    //   interval$.subscribe((value) =>\n    //     console.log('Observable démarre aprés 3sec', value)\n    //   );\n    // }, 3000);\n    // Finalement, on assigne à la propriété `interval$` (qui est de type Observable<number>) un Observable\n    // généré par la méthode `interval(1000)`. Cela crée un flux d'événements qui émet un nombre chaque seconde\n    // Le premier opérateur que vous allez utiliser est l'opérateur  map()  qui permet de transformer les émissions d'un Observable\n    // this.interval$ = interval(1000).pipe(map((value) => value * 10));\n    this.interval$ = interval(1000).pipe(\n    // L'opérateur  filter()  permet de filtrer les émissions, laissant passer uniquement celles qui vous intéressent.\n    filter(value => value % 3 === 0),\n    // Attention ici on change le tye pe donnée, il faut donc changer le type de la propriété interval$ our string\n    map(value => value % 2 === 0 ? `Je suis ${value} et je suis pair !` : `Je suis ${value} et je suis impair !`),\n    // Effet secondaire avec tap()\n    // L'opérator tap() permet de fair zquelque chose sur les émissions d'un Observable\n    tap(text => this.logger(text)));\n  }\n  logger(text) {\n    console.log(`Log: ${text}`);\n  }\n  static {\n    this.ɵfac = function AppComponent_Factory(t) {\n      return new (t || AppComponent)();\n    };\n  }\n  static {\n    this.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n      type: AppComponent,\n      selectors: [[\"app-root\"]],\n      decls: 2,\n      vars: 0,\n      template: function AppComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelement(0, \"app-header\")(1, \"router-outlet\");\n        }\n      },\n      dependencies: [i1.RouterOutlet, i2.HeaderComponent],\n      styles: [\"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsInNvdXJjZVJvb3QiOiIifQ== */\"]\n    });\n  }\n}","map":{"version":3,"names":["filter","interval","tap","map","AppComponent","ngOnInit","interval$","pipe","value","text","logger","console","log","selectors","decls","vars","template","AppComponent_Template","rf","ctx","i0","ɵɵelement"],"sources":["C:\\Users\\User\\Work\\Tuto\\Openclassrooms\\snapface\\frontend\\src\\app\\app.component.ts","C:\\Users\\User\\Work\\Tuto\\Openclassrooms\\snapface\\frontend\\src\\app\\app.component.html"],"sourcesContent":["// DECOMMENTER POUR TESTER OBSERVABLES\n// import { Component, OnInit } from '@angular/core';\n// import { interval, of } from 'rxjs';\n// import {\n//   concatMap,\n//   mergeMap,\n//   delay,\n//   exhaustMap,\n//   map,\n//   switchMap,\n//   take,\n//   tap,\n// } from 'rxjs/operators';\n\n// @Component({\n//   selector: 'app-root',\n//   templateUrl: './app.component.html',\n//   styleUrls: ['./app.component.scss'],\n// })\n// export class AppComponent implements OnInit {\n//   redTrainsCalled = 0;\n//   yellowTrainsCalled = 0;\n\n//   ngOnInit() {\n//     interval(500)\n//       .pipe(\n//         take(10),\n//         map((value) => (value % 2 === 0 ? 'rouge' : 'jaune')),\n//         tap((color) =>\n//           console.log(\n//             `La lumière s'allume en %c${color}`,\n//             `color: ${this.translateColor(color)}`\n//           )\n//         ),\n//         mergeMap((color) => this.getTrainObservable$(color)),\n//         tap((train) =>\n//           console.log(\n//             `Train %c${train.color} ${train.trainIndex} arrivé !`,\n//             `font-weight: bold; color: ${this.translateColor(train.color)}`\n//           )\n//         )\n//       )\n//       .subscribe();\n//   }\n\n//   getTrainObservable$(color: 'rouge' | 'jaune') {\n//     const isRedTrain = color === 'rouge';\n//     isRedTrain ? this.redTrainsCalled++ : this.yellowTrainsCalled++;\n//     const trainIndex = isRedTrain\n//       ? this.redTrainsCalled\n//       : this.yellowTrainsCalled;\n//     console.log(\n//       `Train %c${color} ${trainIndex} appelé !`,\n//       `text-decoration: underline; color: ${this.translateColor(color)}`\n//     );\n//     return of({ color, trainIndex }).pipe(delay(isRedTrain ? 5000 : 6000));\n//   }\n\n//   translateColor(color: 'rouge' | 'jaune') {\n//     return color === 'rouge' ? 'red' : 'yellow';\n//   }\n// }\n\n// DECOMMENTER POUR SANS OBSERVABLE\nimport { Component, OnInit } from '@angular/core';\nimport { filter, interval, Observable, tap } from 'rxjs'; // Importation des fonctions et classes nécessaires depuis la bibliothèque RxJS.\nimport { map } from 'rxjs';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.scss'],\n})\n\n// La classe AppComponent est le composant principal de cette application. Elle implémente l'interface OnInit, ce qui signifie qu'une méthode ngOnInit sera appelée après l'initialisation du composant\nexport class AppComponent implements OnInit {\n  // Création d'une propriété `interval$` de type Observable<number>. Le point d'exclamation (`!`) signifie que TypeScript accepte que cette variable soit définie plus tard (après l'initialisation)\n  interval$!: Observable<string>;\n\n  // Méthode ngOnInit, exécutée juste après la création du composant, idéale pour l'initialisation des variables ou l'appel des observables\n  ngOnInit(): void {\n    // Le $ est une convention qui permet de dire que c'est un Obervable\n    // Toutes les secondes, l'Observable émet un nombre\n    // const interval$ = interval(1000);\n\n    // // Ce nombre est ensuite capté et traité par la méthode passée à  subscribe()\n    // interval$.subscribe((value) => console.log('Observable', value));\n\n    // // Test qui prmet d'identifier plusieurs d'instances d'Obervables\n    // setTimeout(() => {\n    //   interval$.subscribe((value) =>\n    //     console.log('Observable démarre aprés 3sec', value)\n    //   );\n    // }, 3000);\n\n    // Finalement, on assigne à la propriété `interval$` (qui est de type Observable<number>) un Observable\n    // généré par la méthode `interval(1000)`. Cela crée un flux d'événements qui émet un nombre chaque seconde\n    // Le premier opérateur que vous allez utiliser est l'opérateur  map()  qui permet de transformer les émissions d'un Observable\n    // this.interval$ = interval(1000).pipe(map((value) => value * 10));\n    this.interval$ = interval(1000).pipe(\n      // L'opérateur  filter()  permet de filtrer les émissions, laissant passer uniquement celles qui vous intéressent.\n      filter((value) => value % 3 === 0),\n      // Attention ici on change le tye pe donnée, il faut donc changer le type de la propriété interval$ our string\n      map((value) =>\n        value % 2 === 0\n          ? `Je suis ${value} et je suis pair !`\n          : `Je suis ${value} et je suis impair !`\n      ),\n      // Effet secondaire avec tap()\n      // L'opérator tap() permet de fair zquelque chose sur les émissions d'un Observable\n      tap((text) => this.logger(text))\n    );\n  }\n  logger(text: string) {\n    console.log(`Log: ${text}`);\n  }\n}\n","<!-- <app-face-snap [faceSnap] = \"mySnap\" />\r\n<app-face-snap [faceSnap] = \"myOtherSnap\" />\r\n<app-face-snap [faceSnap] = \"myLastSnap\" /> -->\r\n\r\n<!-- <app-face-snap [faceSnap] = \"mySnap\" *ngIf = \"mySnap.snaps >= 5\" />\r\n<app-face-snap [faceSnap] = \"myOtherSnap\" *ngIf = \"myOtherSnap.snaps >= 5\" />\r\n<app-face-snap [faceSnap] = \"myLastSnap\" *ngIf = \"myLastSnap.snaps >= 5\" /> -->\r\n\r\n<!-- Au lieu d'avoir 3 instances de faceSnap on utilise *ngFor qui permet d'itérer -->\r\n<!-- <app-face-snap\r\n  *ngFor=\"let faceSnapElementInArray of faceSnaps\"\r\n  [faceSnap]=\"faceSnapElementInArray\"\r\n></app-face-snap> -->\r\n\r\n<!-- AppComponent ne contient maintenant que ce qu'il faut pour afficher les elements principaux de l'app -->\r\n\r\n<!-- A DECOMMENTER -->\r\n<app-header></app-header>\r\n<!-- Remplacé par la route -->\r\n<!-- <app-face-snap-list></app-face-snap-list> -->\r\n\r\n<!-- <router-outlet> est un point d'insertion pour les composants correspondant aux routes définies dans ton application. -->\r\n<!-- Ici, <router-outlet> est la balise qui dit à Angular où injecter dynamiquement le composant en fonction de la route. Le AppHeader restera affiché sur toutes les routes, ce qui est logique pour un en-tête de navigation. -->\r\n\r\n<!-- A DECOMMENTER -->\r\n<router-outlet></router-outlet>\r\n\r\n<!-- COMMENTER POUR TESTER OBSERVABLES DE HAUT NIVEAU -->\r\n<!-- <h1>{{ interval$ | async }}</h1> -->\r\n"],"mappings":"AAiEA,SAASA,MAAM,EAAEC,QAAQ,EAAcC,GAAG,QAAQ,MAAM,CAAC,CAAC;AAC1D,SAASC,GAAG,QAAQ,MAAM;;;;AAQ1B;AACA,OAAM,MAAOC,YAAY;EAIvB;EACAC,QAAQA,CAAA;IACN;IACA;IACA;IAEA;IACA;IAEA;IACA;IACA;IACA;IACA;IACA;IAEA;IACA;IACA;IACA;IACA,IAAI,CAACC,SAAS,GAAGL,QAAQ,CAAC,IAAI,CAAC,CAACM,IAAI;IAClC;IACAP,MAAM,CAAEQ,KAAK,IAAKA,KAAK,GAAG,CAAC,KAAK,CAAC,CAAC;IAClC;IACAL,GAAG,CAAEK,KAAK,IACRA,KAAK,GAAG,CAAC,KAAK,CAAC,GACX,WAAWA,KAAK,oBAAoB,GACpC,WAAWA,KAAK,sBAAsB,CAC3C;IACD;IACA;IACAN,GAAG,CAAEO,IAAI,IAAK,IAAI,CAACC,MAAM,CAACD,IAAI,CAAC,CAAC,CACjC;EACH;EACAC,MAAMA,CAACD,IAAY;IACjBE,OAAO,CAACC,GAAG,CAAC,QAAQH,IAAI,EAAE,CAAC;EAC7B;;;uBAxCWL,YAAY;IAAA;EAAA;;;YAAZA,YAAY;MAAAS,SAAA;MAAAC,KAAA;MAAAC,IAAA;MAAAC,QAAA,WAAAC,sBAAAC,EAAA,EAAAC,GAAA;QAAA,IAAAD,EAAA;UC1DzBE,EAAA,CAAAC,SAAA,iBAAyB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}